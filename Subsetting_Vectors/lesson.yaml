- Class: meta
  Course: Programando en R
  Lesson: Subcomjuntos de Vectores
  Author: Nick Carchedi
  Type: Standard
  Organization: JHU Biostat
  Version: 2.2.0

- Class: text
  Output: En esta lección, vamos a ver cómo extraer elementos de un vector basado en algunas condiciones que especifiquemos.

- Class: text
  Output: Por ejemplo, sólo puede estar interesado en los primeros 20 elementos de un vector, o sólo los elementos que no son NA, o sólo aquellos que son positivos o corresponden a una variable específica de interés. Al final de esta lección, usted sabrá cómo manejar cada uno de estos escenarios.

- Class: cmd_question
  Output: He creado para ti un vector llamado x que contiene una ordenación aleatoria de 20 números (de una distribución normal estándar) y 20 NAs. Escriba x ahora para ver lo que contiene.
  CorrectAnswer: x
  AnswerTests: omnitest(correctExpr='x')
  Hint: Escriba x para ver su contenido.

- Class: text
  Output: La forma en que dices a R que deseas seleccionar algunos elementos particulares (es decir, un "subconjunto") de un vector, es mediante la colocación de un "vector índice", entre corchetes, inmediatamente después del nombre del vector.

- Class: cmd_question
  Output: Para un ejemplo sencillo, intente con x[1:10] para ver los primeros diez elementos de x.
  CorrectAnswer: x[1:10]
  AnswerTests: omnitest(correctExpr='x[1:10]')
  Hint: Vea los diez primeros elementos de x con x[1:10].

- Class: text
  Output: Los vectores índice vienen en cuatro sabores diferentes -- vectores lógicos, vectores de enteros positivos, vectores de enteros negativos y vectores de cadenas de caracteres -- cada uno de los cuales vamos a cubrir en esta lección.

- Class: text
  Output: Empecemos por la indexación con vectores lógicos. Un escenario común cuando se trabaja con datos del mundo real es que queremos extraer todos los elementos de un vector que no son NA (es decir, los datos que faltan). Recordemos que is.na(x) obtiene un vector de valores lógicos de la misma longitud que x, con TRUEs correspondientes a los valores de NA en x y FALSEs correspondientes a valores no NA en x.

- Class: mult_question
  Output: ¿Qué opinas sobre lo que x[is.na(x)] te dará?
  AnswerChoices: Un vector de todas las NAs; Un vector sin las NAs; Un vector de TRUEs y FALSEs; Un vector de longitud 0
  CorrectAnswer: Un vector de todas las NAs
  AnswerTests: omnitest(correctVal="Un vector de todas las NAs")
  Hint: Recuerde que is.na(x) nos dice donde las AN están en un vector. Así que si contruimos un subconjunto x basado en eso, ¿qué es lo que usted espera que suceda?

- Class: cmd_question
  Output: Demuestrese a sí mismo escribiendo x[is.na(x)].
  CorrectAnswer: x[is.na(x)]
  AnswerTests: omnitest(correctExpr='x[is.na(x)]')
  Hint: Escriba x[is.na(x)] para ver que usted obtendrá todos los NAs, lo que claramente, no es lo que queremos!

- Class: cmd_question
  Output: Recordemos que `!` nos da la negación de una expresión lógica, por lo !is.na(x) se puede leer como "no es NA". Por lo tanto, si queremos crear un vector llamado y que contenga todos los valores no-NA de x, podemos utilizar y <- x[!is.na(x)]. Dese la oportunidad.
  CorrectAnswer: y <- x[!is.na(x)]
  AnswerTests: omnitest(correctExpr='y <- x[!is.na(x)]')
  Hint: Escriba y <- x[!is.na(x)] para capturar todos los valores no faltantes de x.

- Class: cmd_question
  Output: Imprimir y en la consola.
  CorrectAnswer: 'y'
  AnswerTests: omnitest(correctExpr='y')
  Hint: Escriba y para ver su contenido.

- Class: text
  Output: Ahora que hemos aislado los valores no perdidos de x y los pusimos en y, podemos crear los subconjuntos y como nos plazca.

- Class: mult_question
  Output: Recall that the expression y > 0 will give us a vector of logical values the same length as y, with TRUEs corresponding to values of y that are greater than zero and FALSEs corresponding to values of y that are less than or equal to zero. What do you think y[y > 0] will give you?
  Recordemos que la expresión y > 0 nos dará un vector de valores lógicos de la misma longitud de y, con TRUEs correspondientes a los valores de y que son mayores que cero y FALSEs correspondientes a valores de y que son menos que o igual a cero . ¿Qué piensa usted de lo que y[y > 0] le dará?
  AnswerChoices: A vector of all the positive elements of y; A vector of all the negative elements of y; A vector of all NAs; A vector of length 0; A vector of TRUEs and FALSEs
  CorrectAnswer: A vector of all the positive elements of y
  AnswerTests: omnitest(correctVal="A vector of all the positive elements of y")
  Hint: The logical expression y > 0 will give us TRUE for each element of y that is positive. Based on that, what do you think y[y > 0] will return?

- Class: cmd_question
  Output: Type y[y > 0] to see that we get all of the positive elements of y, which are also the positive elements of our original vector x.
  CorrectAnswer: y[y > 0]
  AnswerTests: omnitest(correctExpr='y[y > 0]')
  Hint: Type y[y > 0] to view only the positive elements of y.

- Class: cmd_question
  Output: You might wonder why we didn't just start with x[x > 0] to isolate the positive elements of x. Try that now to see why.
  CorrectAnswer: x[x > 0]
  AnswerTests: omnitest(correctExpr='x[x > 0]')
  Hint: Try x[x > 0] to see why we didn't use this approach.

- Class: text
  Output: Since NA is not a value, but rather a placeholder for an unknown quantity, the expression NA > 0 evaluates to NA. Hence we get a bunch of NAs mixed in with our positive numbers when we do this.

- Class: cmd_question
  Output: Combining our knowledge of logical operators with our new knowledge of subsetting, we could do this -- x[!is.na(x) & x > 0]. Try it out.
  CorrectAnswer: x[!is.na(x) & x > 0]
  AnswerTests: omnitest(correctExpr='x[!is.na(x) & x > 0]')
  Hint: Try x[!is.na(x) & x > 0] to see what you get.

- Class: text
  Output: In this case, we request only values of x that are both non-missing AND greater than zero.

- Class: text
  Output: I've already shown you how to subset just the first ten values of x using x[1:10]. In this case, we're providing a vector of positive integers inside of the square brackets, which tells R to return only the elements of x numbered 1 through 10.

- Class: text
  Output: Many programming languages use what's called 'zero-based indexing', which means that the first element of a vector is considered element 0. R uses 'one-based indexing', which (you guessed it!) means the first element of a vector is considered element 1.

- Class: cmd_question
  Output: Can you figure out how we'd subset the 3rd, 5th, and 7th elements of x? Hint -- Use the c() function to specify the element numbers as a numeric vector.
  CorrectAnswer: x[c(3, 5, 7)]
  AnswerTests: omnitest(correctExpr='x[c(3, 5, 7)]')
  Hint: Create a vector of indexes with c(3, 5, 7), then put that inside of the square brackets.

- Class: cmd_question
  Output: It's important that when using integer vectors to subset our vector x, we stick with the set of indexes {1, 2, ..., 40} since x only has 40 elements. What happens if we ask for the zeroth element of x (i.e. x[0])? Give it a try.
  CorrectAnswer: x[0]
  AnswerTests: omnitest(correctExpr='x[0]')
  Hint: Try x[0] to see what happens when we refer to the zeroth element of a vector, which is not defined in R.

- Class: cmd_question
  Output: As you might expect, we get nothing useful. Unfortunately, R doesn't prevent us from doing this. What if we ask for the 3000th element of x? Try it out.
  CorrectAnswer: x[3000]
  AnswerTests: omnitest(correctExpr='x[3000]')
  Hint: Request the 3000th element of x (which does not exist) with x[3000].

- Class: text
  Output: Again, nothing useful, but R doesn't prevent us from asking for it. This should be a cautionary tale. You should always make sure that what you are asking for is within the bounds of the vector you're working with.

- Class: text
  Output: What if we're interested in all elements of x EXCEPT the 2nd and 10th? It would be pretty tedious to construct a vector containing all numbers 1 through 40 EXCEPT 2 and 10.

- Class: cmd_question
  Output: Luckily, R accepts negative integer indexes. Whereas x[c(2, 10)] gives us ONLY the 2nd and 10th elements of x, x[c(-2, -10)] gives us all elements of x EXCEPT for the 2nd and 10 elements.  Try x[c(-2, -10)] now to see this.
  CorrectAnswer: x[c(-2, -10)]
  AnswerTests: omnitest(correctExpr='x[c(-2, -10)]')
  Hint: Give x[c(-2, -10)] a try.

- Class: cmd_question
  Output: A shorthand way of specifying multiple negative numbers is to put the negative sign out in front of the vector of positive numbers. Type x[-c(2, 10)] to get the exact same result.
  CorrectAnswer: x[-c(2, 10)]
  AnswerTests: omnitest(correctExpr='x[-c(2, 10)]')
  Hint: Use x[-c(2, 10)] to simply things a bit. This could be a time saver if specifying many negative indexes.

- Class: text
  Output: So far, we've covered three types of index vectors -- logical, positive integer, and negative integer. The only remaining type requires us to introduce the concept of 'named' elements.

- Class: cmd_question
  Output: Create a numeric vector with three named elements using vect <- c(foo = 11, bar = 2, norf = NA).
  CorrectAnswer: vect <- c(foo = 11, bar = 2, norf = NA)
  AnswerTests: omnitest(correctExpr='vect <- c(foo = 11, bar = 2, norf = NA)')
  Hint: Create a named vector with vect <- c(foo = 11, bar = 2, norf = NA).

- Class: cmd_question
  Output: When we print vect to the console, you'll see that each element has a name. Try it out.
  CorrectAnswer: vect
  AnswerTests: omnitest(correctExpr='vect')
  Hint: Type vect to view its contents.

- Class: cmd_question
  Output: We can also get the names of vect by passing vect as an argument to the names() function. Give that a try.
  CorrectAnswer: names(vect)
  AnswerTests: omnitest(correctExpr='names(vect)')
  Hint: Check out the results of names(vect).

- Class: cmd_question
  Output: Alternatively, we can create an unnamed vector vect2 with c(11, 2, NA). Do that now.
  CorrectAnswer: vect2 <- c(11, 2, NA)
  AnswerTests: omnitest(correctExpr='vect2 <- c(11, 2, NA)')
  Hint: Create an ordinary (unnamed) vector called vect2 that contains c(11, 2, NA).

- Class: cmd_question
  Output: Then, we can add the `names` attribute to vect2 after the fact with names(vect2) <- c("foo", "bar", "norf"). Go ahead.
  CorrectAnswer: names(vect2) <- c("foo", "bar", "norf")
  AnswerTests: omnitest(correctExpr='names(vect2) <- c("foo", "bar", "norf")')
  Hint: Add names to vect2 with names(vect2) <- c("foo", "bar", "norf").

- Class: cmd_question
  Output: Now, let's check that vect and vect2 are the same by passing them as arguments to the identical() function.
  CorrectAnswer: identical(vect, vect2)
  AnswerTests: any_of_exprs('identical(vect, vect2)', 'identical(vect2, vect)')
  Hint: The identical() function tells us if its first two arguments are, well, identical.

- Class: text
  Output: Indeed, vect and vect2 are identical named vectors.

- Class: mult_question
  Output: Now, back to the matter of subsetting a vector by named elements. Which of the following commands do you think would give us the second element of vect?
  AnswerChoices: vect["bar"]; vect[bar]; vect["2"]
  CorrectAnswer: vect["bar"]
  AnswerTests: omnitest(correctVal='vect["bar"]')
  Hint: If we want the element named "bar" (i.e. the second element of vect), which command would get us that?

- Class: cmd_question
  Output: Now, try it out.
  CorrectAnswer: vect["bar"]
  AnswerTests: omnitest(correctExpr='vect["bar"]')
  Hint: Try vect["bar"].

- Class: cmd_question
  Output: Likewise, we can specify a vector of names with vect[c("foo", "bar")]. Try it out.
  CorrectAnswer: vect[c("foo", "bar")]
  AnswerTests: omnitest(correctExpr='vect[c("foo", "bar")]')
  Hint: Use vect[c("foo", "bar")] to get only the elements of vect named "foo" and "bar".

- Class: text
  Output: Now you know all four methods of subsetting data from vectors. Different approaches are best in different scenarios and when in doubt, try it out!

- Class: mult_question
  Output: Would you like to inform someone about your successful completion of this lesson?
  CorrectAnswer: NULL
  AnswerChoices: Yes; No
  AnswerTests: notify()
  Hint: NULL
